<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AR Body Tracker - Bahubali Armour</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            background: #000;
        }

        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        #videoElement {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
        }

        #canvasElement {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            transform: scaleX(-1);
        }

        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 12px;
            color: white;
            max-width: 300px;
            backdrop-filter: blur(10px);
        }

        button {
            width: 100%;
            padding: 12px;
            margin: 10px 0;
            border: none;
            border-radius: 8px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: transform 0.2s;
        }

        button:hover {
            transform: scale(1.05);
        }

        button:disabled {
            background: #555;
            cursor: not-allowed;
        }

        .stats {
            margin-top: 15px;
            padding: 10px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            font-size: 14px;
        }

        .stats-item {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
        }

        .stats-label {
            color: #aaa;
        }

        .stats-value {
            color: #0f0;
            font-weight: bold;
        }

        h3 {
            margin: 15px 0 10px 0;
            font-size: 16px;
            color: #667eea;
        }

        .bone-info {
            font-size: 12px;
            padding: 5px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
            margin: 3px 0;
        }

        #status {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 10px 20px;
            border-radius: 8px;
            color: #0f0;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div id="container">
        <video id="videoElement" autoplay playsinline></video>
        <canvas id="canvasElement"></canvas>
        
        <div id="controls">
            <h2 style="margin-bottom: 15px;">üõ°Ô∏è AR Armour</h2>
            <button id="startBtn">Start Tracking</button>
            
            <div class="stats">
                <div class="stats-item">
                    <span class="stats-label">FPS:</span>
                    <span class="stats-value" id="fps">0</span>
                </div>
                <div class="stats-item">
                    <span class="stats-label">Landmarks:</span>
                    <span class="stats-value" id="landmarks">0/33</span>
                </div>
                <div class="stats-item">
                    <span class="stats-label">Armour:</span>
                    <span class="stats-value" id="modelStatus">Not Loaded</span>
                </div>
            </div>

            <h3>üéØ Armour Settings</h3>
            <div class="stats">
                <div class="stats-item">
                    <span class="stats-label">Scale:</span>
                    <span class="stats-value" id="scaleInfo">Auto</span>
                </div>
                <div class="stats-item">
                    <span class="stats-label">Bones Mapped:</span>
                    <span class="stats-value" id="bonesMapped">0/20</span>
                </div>
                <div class="stats-item">
                    <span class="stats-label">Alignment:</span>
                    <span class="stats-value" id="alignment">Centered</span>
                </div>
            </div>

            <h3>üìä Body Metrics</h3>
            <div class="stats">
                <div class="stats-item">
                    <span class="stats-label">Body Height:</span>
                    <span class="stats-value" id="bodyHeight">--</span>
                </div>
                <div class="stats-item">
                    <span class="stats-label">Shoulder Width:</span>
                    <span class="stats-value" id="shoulderWidth">--</span>
                </div>
                <div class="stats-item">
                    <span class="stats-label">Torso Length:</span>
                    <span class="stats-value" id="torsoLength">--</span>
                </div>
            </div>
        </div>

        <div id="status">Click "Start Tracking" to wear the armour</div>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.158.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        // MediaPipe Pose Detection
        const videoElement = document.getElementById('videoElement');
        const canvasElement = document.getElementById('canvasElement');
        const canvasCtx = canvasElement.getContext('2d');
        const startBtn = document.getElementById('startBtn');
        const statusDiv = document.getElementById('status');

        let pose, camera, armourModel, skeleton, bones = {};
        let tracking = false;
        let lastFrameTime = Date.now();
        let frameCount = 0;
        let bodyMetrics = {
            height: 0,
            shoulderWidth: 0,
            torsoLength: 0,
            hipWidth: 0
        };
        let autoScale = 1.0;

        // Three.js Scene Setup
        const scene = new THREE.Scene();
        const threeCamera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        threeCamera.position.z = 5;

        const renderer = new THREE.WebGLRenderer({ 
            canvas: canvasElement, 
            alpha: true,
            antialias: true 
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x000000, 0);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
        directionalLight.position.set(5, 5, 5);
        scene.add(directionalLight);

        const pointLight = new THREE.PointLight(0xffffff, 0.4);
        pointLight.position.set(-5, 5, 5);
        scene.add(pointLight);

        // Load 3D Armour Model
        const loader = new GLTFLoader();
        loader.load(
            'armour_bahubali.glb',
            (gltf) => {
                armourModel = gltf.scene;
                
                // Find skeleton in the loaded model
                armourModel.traverse((child) => {
                    if (child.isSkinnedMesh) {
                        skeleton = child.skeleton;
                        console.log('Skeleton found:', skeleton);
                        
                        // Map bones by name
                        skeleton.bones.forEach((bone) => {
                            bones[bone.name.toLowerCase()] = bone;
                            console.log('Bone found:', bone.name);
                        });
                    }
                });

                // Set initial position and scale
                armourModel.position.set(0, 0, 0);
                armourModel.scale.set(1, 1, 1);
                
                scene.add(armourModel);
                document.getElementById('modelStatus').textContent = 'Loaded';
                document.getElementById('bonesMapped').textContent = `${Object.keys(bones).length}/20`;
                updateStatus('Armour loaded! Start tracking to wear it.');
            },
            (progress) => {
                const percent = (progress.loaded / progress.total * 100).toFixed(0);
                updateStatus(`Loading armour... ${percent}%`);
            },
            (error) => {
                console.error('Error loading model:', error);
                updateStatus('Error loading armour model');
            }
        );

        // MediaPipe Pose Landmarker indices
        const POSE_LANDMARKS = {
            NOSE: 0,
            LEFT_EYE_INNER: 1,
            LEFT_EYE: 2,
            LEFT_EYE_OUTER: 3,
            RIGHT_EYE_INNER: 4,
            RIGHT_EYE: 5,
            RIGHT_EYE_OUTER: 6,
            LEFT_EAR: 7,
            RIGHT_EAR: 8,
            MOUTH_LEFT: 9,
            MOUTH_RIGHT: 10,
            LEFT_SHOULDER: 11,
            RIGHT_SHOULDER: 12,
            LEFT_ELBOW: 13,
            RIGHT_ELBOW: 14,
            LEFT_WRIST: 15,
            RIGHT_WRIST: 16,
            LEFT_PINKY: 17,
            RIGHT_PINKY: 18,
            LEFT_INDEX: 19,
            RIGHT_INDEX: 20,
            LEFT_THUMB: 21,
            RIGHT_THUMB: 22,
            LEFT_HIP: 23,
            RIGHT_HIP: 24,
            LEFT_KNEE: 25,
            RIGHT_KNEE: 26,
            LEFT_ANKLE: 27,
            RIGHT_ANKLE: 28,
            LEFT_HEEL: 29,
            RIGHT_HEEL: 30,
            LEFT_FOOT_INDEX: 31,
            RIGHT_FOOT_INDEX: 32
        };

        // Calculate body metrics from landmarks
        function calculateBodyMetrics(landmarks) {
            if (!landmarks || landmarks.length < 33) return;

            // Calculate distances in 3D space
            const leftShoulder = landmarks[POSE_LANDMARKS.LEFT_SHOULDER];
            const rightShoulder = landmarks[POSE_LANDMARKS.RIGHT_SHOULDER];
            const leftHip = landmarks[POSE_LANDMARKS.LEFT_HIP];
            const rightHip = landmarks[POSE_LANDMARKS.RIGHT_HIP];
            const leftAnkle = landmarks[POSE_LANDMARKS.LEFT_ANKLE];
            const rightAnkle = landmarks[POSE_LANDMARKS.RIGHT_ANKLE];
            const nose = landmarks[POSE_LANDMARKS.NOSE];

            // Shoulder width
            bodyMetrics.shoulderWidth = Math.sqrt(
                Math.pow(rightShoulder.x - leftShoulder.x, 2) +
                Math.pow(rightShoulder.y - leftShoulder.y, 2) +
                Math.pow(rightShoulder.z - leftShoulder.z, 2)
            );

            // Hip width
            bodyMetrics.hipWidth = Math.sqrt(
                Math.pow(rightHip.x - leftHip.x, 2) +
                Math.pow(rightHip.y - leftHip.y, 2) +
                Math.pow(rightHip.z - leftHip.z, 2)
            );

            // Torso length (shoulder center to hip center)
            const shoulderCenter = {
                x: (leftShoulder.x + rightShoulder.x) / 2,
                y: (leftShoulder.y + rightShoulder.y) / 2,
                z: (leftShoulder.z + rightShoulder.z) / 2
            };
            const hipCenter = {
                x: (leftHip.x + rightHip.x) / 2,
                y: (leftHip.y + rightHip.y) / 2,
                z: (leftHip.z + rightHip.z) / 2
            };
            
            bodyMetrics.torsoLength = Math.sqrt(
                Math.pow(hipCenter.x - shoulderCenter.x, 2) +
                Math.pow(hipCenter.y - shoulderCenter.y, 2) +
                Math.pow(hipCenter.z - shoulderCenter.z, 2)
            );

            // Total body height (nose to average ankle)
            const avgAnkle = {
                x: (leftAnkle.x + rightAnkle.x) / 2,
                y: (leftAnkle.y + rightAnkle.y) / 2,
                z: (leftAnkle.z + rightAnkle.z) / 2
            };
            
            bodyMetrics.height = Math.sqrt(
                Math.pow(nose.x - avgAnkle.x, 2) +
                Math.pow(nose.y - avgAnkle.y, 2) +
                Math.pow(nose.z - avgAnkle.z, 2)
            );

            // Calculate auto-scale based on torso length and shoulder width
            // Assuming standard model torso is ~0.5 units and shoulders ~0.4 units
            const torsoScale = bodyMetrics.torsoLength / 0.3;
            const shoulderScale = bodyMetrics.shoulderWidth / 0.25;
            autoScale = (torsoScale + shoulderScale) / 2;

            // Update UI
            document.getElementById('bodyHeight').textContent = (bodyMetrics.height * 100).toFixed(1) + ' cm';
            document.getElementById('shoulderWidth').textContent = (bodyMetrics.shoulderWidth * 100).toFixed(1) + ' cm';
            document.getElementById('torsoLength').textContent = (bodyMetrics.torsoLength * 100).toFixed(1) + ' cm';
            document.getElementById('scaleInfo').textContent = autoScale.toFixed(2) + 'x';
        }

        // Convert normalized coordinates to Three.js world space
        function landmarkToWorld(landmark, videoWidth, videoHeight) {
            // Normalize coordinates to -1 to 1 range
            const x = -(landmark.x * 2 - 1) * 3; // Flip X for mirror
            const y = (1 - landmark.y * 2) * 2.5; // Flip Y for correct orientation
            const z = -landmark.z * 3; // Z depth
            
            return new THREE.Vector3(x, y, z);
        }

        // Update armour model position and bones
        function updateArmourModel(landmarks) {
            if (!armourModel || !landmarks || landmarks.length < 33) return;

            const videoWidth = videoElement.videoWidth;
            const videoHeight = videoElement.videoHeight;

            // Calculate hip center as the root position
            const leftHip = landmarks[POSE_LANDMARKS.LEFT_HIP];
            const rightHip = landmarks[POSE_LANDMARKS.RIGHT_HIP];
            const hipCenter = {
                x: (leftHip.x + rightHip.x) / 2,
                y: (leftHip.y + rightHip.y) / 2,
                z: (leftHip.z + rightHip.z) / 2
            };

            // Set model root position to hip center
            const hipPosition = landmarkToWorld(hipCenter, videoWidth, videoHeight);
            armourModel.position.copy(hipPosition);

            // Apply auto-calculated scale
            const scale = autoScale * 2.5; // Adjust multiplier as needed
            armourModel.scale.set(scale, scale, scale);

            // Map skeleton bones to MediaPipe landmarks
            if (skeleton && bones) {
                mapBonesToLandmarks(landmarks, videoWidth, videoHeight, hipPosition);
            }
        }

        // Map armour bones to body landmarks
        function mapBonesToLandmarks(landmarks, videoWidth, videoHeight, rootPosition) {
            // Define bone mappings (adjust bone names based on your model)
            const boneMap = {
                // Spine/Torso
                'spine': { landmark: POSE_LANDMARKS.LEFT_HIP, type: 'position' },
                'spine1': { landmark: POSE_LANDMARKS.LEFT_SHOULDER, type: 'look' },
                'chest': { landmark: POSE_LANDMARKS.LEFT_SHOULDER, type: 'position' },
                
                // Left Arm
                'leftshoulder': { landmark: POSE_LANDMARKS.LEFT_SHOULDER, type: 'position' },
                'leftarm': { landmark: POSE_LANDMARKS.LEFT_SHOULDER, type: 'position' },
                'leftforearm': { landmark: POSE_LANDMARKS.LEFT_ELBOW, type: 'look' },
                'lefthand': { landmark: POSE_LANDMARKS.LEFT_WRIST, type: 'position' },
                
                // Right Arm
                'rightshoulder': { landmark: POSE_LANDMARKS.RIGHT_SHOULDER, type: 'position' },
                'rightarm': { landmark: POSE_LANDMARKS.RIGHT_SHOULDER, type: 'position' },
                'rightforearm': { landmark: POSE_LANDMARKS.RIGHT_ELBOW, type: 'look' },
                'righthand': { landmark: POSE_LANDMARKS.RIGHT_WRIST, type: 'position' },
                
                // Left Leg
                'leftupleg': { landmark: POSE_LANDMARKS.LEFT_HIP, type: 'position' },
                'leftleg': { landmark: POSE_LANDMARKS.LEFT_KNEE, type: 'look' },
                'leftfoot': { landmark: POSE_LANDMARKS.LEFT_ANKLE, type: 'position' },
                
                // Right Leg
                'rightupleg': { landmark: POSE_LANDMARKS.RIGHT_HIP, type: 'position' },
                'rightleg': { landmark: POSE_LANDMARKS.RIGHT_KNEE, type: 'look' },
                'rightfoot': { landmark: POSE_LANDMARKS.RIGHT_ANKLE, type: 'position' },
                
                // Head/Neck
                'neck': { landmark: POSE_LANDMARKS.NOSE, type: 'look' },
                'head': { landmark: POSE_LANDMARKS.NOSE, type: 'position' }
            };

            let mappedCount = 0;

            // Apply bone transformations
            Object.keys(boneMap).forEach((boneName) => {
                const bone = bones[boneName.toLowerCase()];
                if (!bone) return;

                const mapping = boneMap[boneName];
                const landmark = landmarks[mapping.landmark];
                if (!landmark) return;

                const worldPos = landmarkToWorld(landmark, videoWidth, videoHeight);
                
                // Convert to local space relative to root
                const localPos = worldPos.sub(rootPosition);

                if (mapping.type === 'position') {
                    // Direct position mapping
                    bone.position.copy(localPos.divideScalar(autoScale * 2.5));
                } else if (mapping.type === 'look') {
                    // Rotation to look at target
                    const tempMatrix = new THREE.Matrix4();
                    tempMatrix.lookAt(bone.position, localPos.divideScalar(autoScale * 2.5), new THREE.Vector3(0, 1, 0));
                    bone.quaternion.setFromRotationMatrix(tempMatrix);
                }

                mappedCount++;
            });

            document.getElementById('bonesMapped').textContent = `${mappedCount}/${Object.keys(boneMap).length}`;
        }

        // Initialize MediaPipe Pose
        async function initPose() {
            const { PoseLandmarker, FilesetResolver } = await window.mediapipe.tasks.vision;

            const vision = await FilesetResolver.forVisionTasks(
                "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/wasm"
            );

            pose = await PoseLandmarker.createFromOptions(vision, {
                baseOptions: {
                    modelAssetPath: "https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_full/float16/latest/pose_landmarker_full.task",
                    delegate: "GPU"
                },
                runningMode: "VIDEO",
                numPoses: 1,
                minPoseDetectionConfidence: 0.5,
                minPosePresenceConfidence: 0.5,
                minTrackingConfidence: 0.5
            });

            console.log('MediaPipe Pose initialized');
        }

        // Start camera
        async function startCamera() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        width: { ideal: 1280 },
                        height: { ideal: 720 },
                        facingMode: 'user'
                    }
                });

                videoElement.srcObject = stream;
                
                videoElement.addEventListener('loadeddata', () => {
                    canvasElement.width = videoElement.videoWidth;
                    canvasElement.height = videoElement.videoHeight;
                    renderer.setSize(videoElement.videoWidth, videoElement.videoHeight);
                    updateStatus('Camera ready! Tracking started.');
                });

            } catch (error) {
                console.error('Error accessing camera:', error);
                updateStatus('Error: Cannot access camera');
            }
        }

        // Process video frame
        async function processFrame() {
            if (!tracking || !pose) return;

            const currentTime = Date.now();
            
            // Detect pose
            const results = await pose.detectForVideo(videoElement, currentTime);

            // Clear canvas
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);

            if (results.landmarks && results.landmarks.length > 0) {
                const landmarks = results.landmarks[0];
                
                // Calculate body metrics
                calculateBodyMetrics(landmarks);
                
                // Update armour model
                updateArmourModel(landmarks);

                // Draw landmarks for debugging
                drawLandmarks(landmarks);
                
                // Update stats
                document.getElementById('landmarks').textContent = `${landmarks.length}/33`;
            }

            // Calculate FPS
            frameCount++;
            if (currentTime - lastFrameTime >= 1000) {
                document.getElementById('fps').textContent = frameCount;
                frameCount = 0;
                lastFrameTime = currentTime;
            }

            // Render Three.js scene
            renderer.render(scene, threeCamera);

            requestAnimationFrame(processFrame);
        }

        // Draw pose landmarks
        function drawLandmarks(landmarks) {
            const videoWidth = canvasElement.width;
            const videoHeight = canvasElement.height;

            // Draw connections
            canvasCtx.strokeStyle = '#00FF00';
            canvasCtx.lineWidth = 2;

            const connections = [
                [11, 12], [11, 13], [13, 15], [12, 14], [14, 16], // Arms
                [11, 23], [12, 24], [23, 24], // Torso
                [23, 25], [25, 27], [24, 26], [26, 28], // Legs
                [0, 1], [1, 2], [2, 3], [3, 7], // Face left
                [0, 4], [4, 5], [5, 6], [6, 8]  // Face right
            ];

            connections.forEach(([start, end]) => {
                const startLandmark = landmarks[start];
                const endLandmark = landmarks[end];
                
                if (startLandmark && endLandmark) {
                    canvasCtx.beginPath();
                    canvasCtx.moveTo(startLandmark.x * videoWidth, startLandmark.y * videoHeight);
                    canvasCtx.lineTo(endLandmark.x * videoWidth, endLandmark.y * videoHeight);
                    canvasCtx.stroke();
                }
            });

            // Draw landmarks
            canvasCtx.fillStyle = '#FF0000';
            landmarks.forEach((landmark) => {
                const x = landmark.x * videoWidth;
                const y = landmark.y * videoHeight;
                canvasCtx.beginPath();
                canvasCtx.arc(x, y, 4, 0, 2 * Math.PI);
                canvasCtx.fill();
            });
        }

        // Update status message
        function updateStatus(message) {
            statusDiv.textContent = message;
        }

        // Start button handler
        startBtn.addEventListener('click', async () => {
            if (!tracking) {
                startBtn.disabled = true;
                startBtn.textContent = 'Initializing...';
                
                await initPose();
                await startCamera();
                
                tracking = true;
                startBtn.textContent = 'Stop Tracking';
                startBtn.disabled = false;
                
                processFrame();
            } else {
                tracking = false;
                startBtn.textContent = 'Start Tracking';
                
                if (videoElement.srcObject) {
                    videoElement.srcObject.getTracks().forEach(track => track.stop());
                }
                
                updateStatus('Tracking stopped');
            }
        });

        // Handle window resize
        window.addEventListener('resize', () => {
            const width = window.innerWidth;
            const height = window.innerHeight;
            
            threeCamera.aspect = width / height;
            threeCamera.updateProjectionMatrix();
            renderer.setSize(width, height);
        });

        // Load MediaPipe library
        const script = document.createElement('script');
        script.src = 'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/vision_bundle.js';
        script.onload = () => {
            console.log('MediaPipe library loaded');
            updateStatus('Ready! Click "Start Tracking"');
        };
        script.onerror = () => {
            updateStatus('Error loading MediaPipe library');
        };
        document.head.appendChild(script);

    </script>
</body>
</html>
